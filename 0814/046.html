<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Set</title>
</head>
<body>
<script>
    // Set
    // 중복을 허락하지 않는 자료형
    // 중복하지 않는 데이터를 저장할 때 사용, 중복 제거
    let s = new Set();

    s.add(10);
    s.add(20);
    s.add(30);
    s.add(30);
    s.add(30);

    console.log(s); // Set(3) {10, 20, 30}

    let ss = new Set('abcdeeeeeeeee');
    console.log(ss);            // ["a","b","c","d","e"]
    console.log(ss.size);       // 5
    console.log(ss.has('e'));     // true
    console.log(ss.delete('d'));     // true

    for(let value of ss)
        console.log(value);         // 'a', 'b', 'c', 'e'


    //////////////////////////////////////////////////////////////////

    // 교집합 합집합 차집합
    let setA = new Set(['apple', 'banana', 'orange']);
    let setB = new Set(['banana', 'kiwi', 'orange']);

    // 교집합
    let intersection = new Set([...setA].filter(x => setB.has(x)));
    console.log(intersection); // Set(2) {"banana", "orange"}

    // 합집합
    let union = new Set([...setA, ...setB]);
    console.log(union); // Set(4) {"apple", "banana", "orange", "kiwi"}

    // 차집합
    let difference = new Set([...setA].filter(x => !setB.has(x)));
    console.log(difference); // Set(1) {"apple"}

    //////////////////////////////////////////////////////////////////

    // array의 filter와 reduce
    // filter는 안에 들어가는 함수가 true를 리턴하는 요소만 모아서 새로운 배열을 만듦
    let arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
    let result = arr.filter(x => x % 2 === 0);

    // reduce는 배열의 각 요소를 연산
    let arr2 = [1, 2, 3, 4, 5];
    let result2 = arr2.reduce((a,c) => a + c, 0);     // a는 accumulator(누적값), c는 current value(현재 값)
    // 0이 없으면 비어있는 배열일 때 에러
    console.log(result2);
</script>
</body>
</html>